{"version":3,"sources":["shouter.js"],"names":["_toConsumableArray","arr","Array","isArray","i","arr2","length","from","Object","defineProperty","exports","value","require","eventList","oldMessage","caller","event","args","Promise","resolve","then","_context","_ref","context","callback","call","apply","concat","on","channel","route","getOldMessage","push","forEach","val","off","arguments","evList","splice","trigger","_len","_key","results","events","keys","routName","promiseResult","all","save","_deleteAllEvents","shouter"],"mappings":"AAAA,YAiBA,SAASA,oBAAmBC,GAAO,GAAIC,MAAMC,QAAQF,GAAM,CAAE,IAAK,GAAIG,GAAI,EAAGC,EAAOH,MAAMD,EAAIK,QAASF,EAAIH,EAAIK,OAAQF,IAAKC,EAAKD,GAAKH,EAAIG,EAAI,OAAOC,GAAe,MAAOH,OAAMK,KAAKN,GAJtLO,OAAOC,eAAeC,QAAS,cAC3BC,OAAO,IAKXC,QANO,yBAMP,IAAIC,cAOAC,cAQAC,OAAS,SAACC,EAAOC,GACjB,MAAOC,SAAQC,UAAUC,KAAK,WAO1B,GAAIC,GAAUC,CANd,QAAOD,EAAAL,EAAMO,QAAND,EAAeN,EAAMQ,UAAQC,KAAAC,MAAAJ,GAAAD,GAAAM,OAAA3B,mBAAIiB,QAc5CW,GAAK,SAASC,EAASC,EAAON,EAAUD,EAASQ,GAE3CF,IAAWhB,aACbA,UAAUgB,OAGRC,IAASjB,WAAUgB,KACrBhB,UAAUgB,GAASC,OAGvBjB,UAAUgB,GAASC,GAAOE,MACtBR,SAAUA,EACVD,QAASA,IAGTQ,GAAiBF,IAAWf,aAC5BA,WAAWe,GAASI,QAAQ,SAACC,IACrBJ,IAAUI,EAAIJ,OAAmB,MAAVA,IACvBN,EAAiBC,KAAAC,MAARF,GAATD,GAAOI,OAAA3B,mBAAckC,EAAIjB,WAarCkB,IAAM,SAASN,EAASC,EAAON,GAM/B,GALyB,IAArBY,UAAU9B,SACVkB,EAAWM,EACXA,EAAQ,KAGRD,IAAWhB,YAAaiB,IAASjB,WAAUgB,GAE3C,IAAK,GADDQ,GAASxB,UAAUgB,GAASC,GACvB1B,EAAIiC,EAAO/B,OAAS,EAAGF,GAAK,EAAGA,IAChCiC,EAAOjC,GAAGoB,WAAaA,GACvBa,EAAOC,OAAOlC,EAAG,IAa7BmC,QAAU,SAASV,EAASC,GAQ5B,IAAK,GAAIU,GAAOJ,UAAU9B,OARYW,EAAIf,MAAAsC,EAAA,EAAAA,EAAA,EAAA,GAAAC,EAAA,EAAAD,EAAAC,EAAAA,IAAJxB,EAAIwB,EAAA,GAAAL,UAAAK,EAC1C,IAAIC,KAEJ,IAAIb,IAAWhB,WAAW,CACtB,GAAI8B,GAAS9B,UAAUgB,EACvBrB,QAAOoC,KAAKD,GACPV,QAAQ,SAAAY,IACDf,IAAUe,GAAsB,MAAVf,GAA8B,MAAbe,IACvCF,EAAOE,GAAUZ,QAAQ,SAAAjB,GAWzB,MAXkC0B,GAAQV,KAAKjB,OAAOC,EAAOC,QAK7E,GAAI6B,GAAgB5B,QAAQ6B,IAAIL,EAEhC,QACIM,KAAM,WASF,MARMnB,KAAWf,cACbA,WAAWe,OAEff,WAAWe,GAASG,MAChBF,MAAOA,EACPb,KAAMA,KAGFyB,QAASI,IAErBJ,QAASI,IASbG,iBAAmB,WACnBpC,aACAC,eAGAoC,SAAWtB,GAAAA,GAAIO,IAAAA,IAAKI,QAAAA,QAASU,iBAAAA,iBAcjCvC,SAZQwC,QAAAA,QAaRxC,QAbiBkB,GAAAA,GAcjBlB,QAdqByB,IAAAA,IAerBzB,QAf0B6B,QAAAA,QAgB1B7B,QAAQ,WAfOwC","file":"shouter.js","sourcesContent":["'use strict';\n\n// Shouter\n// ---------------\n// Bind a callback function to an event.\n//\n//        var help = function() { alert('HELP!'); };\n//        shouter.on('avalanche', '*', help);\n//        shouter.trigger('avalanche', 'danger');\n//        shouter.off('avalanche', help);\n//\n\n// For some reason some people are still using old browsers and systems\nimport './lib/promise-polyfill';\n\n/**\n * List of registered events\n * @type {Object}\n */\nlet eventList = {};\n\n/**\n * Storage of old messages.\n * Used if a listener wants an already emited message\n * @type {Object}\n */\nlet oldMessage = {};\n\n/**\n * Helper function to make async calls\n * @param {Object}  event\n * @param {Array}   args\n * @return {Promise}\n*/\nlet caller = (event, args)  => {\n    return Promise.resolve().then(() => {\n        return event.context::event.callback(...args);\n    });\n};\n\n\n/**\n * Binds a 'callback' to an event.\n * @param  {String}   channel       Name of the channel\n * @param  {String}   route         Name of the route, optional\n * @param  {function} callback      Callback function\n * @param  {Object}   context       Context of the function 'callback'\n * @param  {Boolian}  getOldMessage Determines if old triggers should be taken under account\n * @return {undefined}\n */\nlet on = function(channel, route, callback, context, getOldMessage) {\n\n    if (!(channel in eventList)) {\n        eventList[channel] = {};\n    }\n\n    if (!(route in eventList[channel])) {\n        eventList[channel][route] = [];\n    }\n\n    eventList[channel][route].push({\n        callback: callback,\n        context: context\n    });\n\n    if (getOldMessage && channel in oldMessage) {\n        oldMessage[channel].forEach((val) => {\n            if (route === val.route || route === '*') {\n                context::callback(...val.args);\n            }\n        });\n    }\n};\n\n/**\n * Remove event(s) from the event-list.\n * @param  {String}   channel    Name of the channel\n * @param  {String}   route      Name of the route, optional\n * @param  {Function} callback   Callback function for selecting a specific event\n * @return {undefined}\n */\nlet off = function(channel, route, callback) {\n    if (arguments.length === 2) {\n        callback = route;\n        route = '*';\n    }\n\n    if (channel in eventList && route in eventList[channel]) {\n        var evList = eventList[channel][route];\n        for (var i = evList.length - 1; i >= 0; i--) {\n            if (evList[i].callback === callback) {\n                evList.splice(i, 1);\n            }\n        }\n    }\n};\n\n/**\n * Trigger one or many events, firing all bound callbacks. All arguments will\n * be passed throw to the callback function.\n * @param  {String} eventName   Name of the event\n * @param  {*args}  arguments   Will be passed throw to the callback function\n * @return {object}\n */\nlet trigger = function(channel, route, ...args) {\n    let results = [];\n\n    if (channel in eventList) {\n        var events = eventList[channel];\n        Object.keys(events)\n            .forEach(routName => {\n                if (route === routName || route === '*' || routName === '*') {\n                    events[routName].forEach(event => results.push(caller(event, args)));\n                }\n            });\n    }\n\n    var promiseResult = Promise.all(results);\n\n    return {\n        save: function() {\n            if (!(channel in oldMessage)) {\n                oldMessage[channel] = [];\n            }\n            oldMessage[channel].push({\n                route: route,\n                args: args\n            });\n\n            return {results: promiseResult};\n        },\n        results: promiseResult\n    };\n};\n\n/**\n * Remove all events\n * Should only be used under test\n * @return {undefined}\n */\nlet _deleteAllEvents = function() {\n    eventList = {};\n    oldMessage = {};\n};\n\nlet shouter = {on, off, trigger, _deleteAllEvents};\n\nexport {shouter, on, off, trigger};\nexport default shouter;\n"],"sourceRoot":"/source/"}
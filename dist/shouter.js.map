{"version":3,"sources":["shouter.js"],"names":["_toConsumableArray","arr","Array","isArray","i","arr2","length","from","require","shouter","eventList","oldMessage","caller","event","args","Promise","resolve","reject","setTimeout","result","undefined","_context","_ref","context","callback","call","apply","concat","e","on","channel","route","getOldMessage","push","forEach","val","off","arguments","evList","splice","trigger","_len","_key","results","events","Object","keys","routName","promiseResult","all","save","_deleteAllEvents","module","exports","__esModule","window"],"mappings":"AAAA,YAEA,SAASA,oBAAmBC,GAAO,GAAIC,MAAMC,QAAQF,GAAM,CAAE,IAAK,GAAIG,GAAI,EAAGC,EAAOH,MAAMD,EAAIK,QAASF,EAAIH,EAAIK,OAAQF,IAAKC,EAAKD,GAAKH,EAAIG,EAAI,OAAOC,GAAe,MAAOH,OAAMK,KAAKN,GActLO,QAHO,mBAEP,IAAIC,YAMAC,aAOAC,cAQAC,OAAS,SAAUC,EAAOC,GAC1B,MAAO,IAAIC,SAAQ,SAACC,EAASC,GACzBC,WAAW,WACP,GAAIC,GAAMC,MACV,KAII,GAAIC,GAAUC,CAHdH,IAASE,EAAAR,EAAMU,QAAND,EAAeT,EAAMW,UAAQC,KAAAC,MAAAJ,GAAAD,GAAAM,OAAA3B,mBAAIc,KAC1CE,EAAQG,GACV,MAAOS,GACLX,EAAOW,QAgBvBnB,SAAQoB,GAAK,SAASC,EAASC,EAAOP,EAAUD,EAASS,GAE/CF,IAAWpB,aACbA,UAAUoB,OAGRC,IAASrB,WAAUoB,KACrBpB,UAAUoB,GAASC,OAGvBrB,UAAUoB,GAASC,GAAOE,MACtBT,SAAUA,EACVD,QAASA,IAGTS,GAAiBF,IAAWnB,aAC5BA,WAAWmB,GAASI,QAAQ,SAACC,IACrBJ,IAAUI,EAAIJ,OAAmB,MAAVA,IACvBP,EAAiBC,KAAAC,MAARF,GAATD,GAAOI,OAAA3B,mBAAcmC,EAAIrB,WAazCL,QAAQ2B,IAAM,SAASN,EAASC,EAAOP,GAMnC,GALyB,IAArBa,UAAU/B,SACVkB,EAAWO,EACXA,EAAQ,KAGRD,IAAWpB,YAAaqB,IAASrB,WAAUoB,GAE3C,IAAK,GADDQ,GAAS5B,UAAUoB,GAASC,GACvB3B,EAAIkC,EAAOhC,OAAS,EAAGF,GAAK,EAAGA,IAChCkC,EAAOlC,GAAGoB,WAAaA,GACvBc,EAAOC,OAAOnC,EAAG,IAajCK,QAAQ+B,QAAU,SAASV,EAASC,GAKhC,IAAK,GAAIU,GAAOJ,UAAU/B,OALgBQ,EAAIZ,MAAAuC,EAAA,EAAAA,EAAA,EAAA,GAAAC,EAAA,EAAAD,EAAAC,EAAAA,IAAJ5B,EAAI4B,EAAA,GAAAL,UAAAK,EAC9C,IAAIC,KAEJ,IAAIb,IAAWpB,WAAW,CACtB,GAAIkC,GAASlC,UAAUoB,EACvBe,QAAOC,KAAKF,GACPV,QAAQ,SAAAa,IACDhB,IAAUgB,GAAsB,MAAVhB,GAA8B,MAAbgB,IACvCH,EAAOG,GAAUb,QAAQ,SAAArB,GAQzB,MARkC8B,GAAQV,KAAKrB,OAAOC,EAAOC,QAK7E,GAAIkC,GAAgBjC,QAAQkC,IAAIN,EAEhC,QACIO,KAAM,WASF,MARMpB,KAAWnB,cACbA,WAAWmB,OAEfnB,WAAWmB,GAASG,MAChBF,MAAOA,EACPjB,KAAMA,KAGF6B,QAASK,IAErBL,QAASK,IASjBvC,QAAQ0C,iBAAmB,WACvBzC,aACAC,eAGkB,gBAAXyC,SAAiD,gBAAnBA,QAAOC,SAC5CA,QAAQC,YAAa,EACrBD,QAAQ5C,QAAUA,QAClB4C,QAAO,WAAW5C,SAElB8C,OAAO9C,QAAUA","file":"shouter.js","sourcesContent":["'use strict';\n\n// Shouter\n// ---------------\n// Bind a callback function to an event.\n//\n//        var help = function() { alert('HELP!'); };\n//        shouter.on('avalanche', '*', help);\n//        shouter.trigger('avalanche', 'danger');\n//        shouter.off('avalanche', help);\n//\n\n// For some reason some people are still using old browsers and systems\nimport 'promise-polyfill';\n\nvar shouter = {};\n\n/**\n * List of registered events\n * @type {Object}\n */\nlet eventList = {};\n\n/**\n * Storage of old messages.\n * Used if a listener wants an already emited message\n * @type {Object}\n */\nlet oldMessage = {};\n\n/**\n * Helper function to make async calls\n * @param {Object}  event\n * @param {Array}   args\n * @return {Promise}\n*/\nlet caller = function (event, args) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            let result;\n            try {\n                result = event.context::event.callback(...args);\n                resolve(result);\n            } catch (e) {\n                reject(e);\n            }\n        });\n    });\n};\n\n\n/**\n * Binds a 'callback' to an event.\n * @param  {String}   channel       Name of the channel\n * @param  {String}   route         Name of the route, optional\n * @param  {function} callback      Callback function\n * @param  {Object}   context       Context of the function 'callback'\n * @param  {Boolian}  getOldMessage Determines if old triggers should be taken under account\n * @return {undefined}\n */\nshouter.on = function(channel, route, callback, context, getOldMessage) {\n\n    if (!(channel in eventList)) {\n        eventList[channel] = {};\n    }\n\n    if (!(route in eventList[channel])) {\n        eventList[channel][route] = [];\n    }\n\n    eventList[channel][route].push({\n        callback: callback,\n        context: context\n    });\n\n    if (getOldMessage && channel in oldMessage) {\n        oldMessage[channel].forEach((val) => {\n            if (route === val.route || route === '*') {\n                context::callback(...val.args);\n            }\n        });\n    }\n};\n\n/**\n * Remove event(s) from the event-list.\n * @param  {String}   channel    Name of the channel\n * @param  {String}   route      Name of the route, optional\n * @param  {Function} callback   Callback function for selecting a specific event\n * @return {undefined}\n */\nshouter.off = function(channel, route, callback) {\n    if (arguments.length === 2) {\n        callback = route;\n        route = '*';\n    }\n\n    if (channel in eventList && route in eventList[channel]) {\n        var evList = eventList[channel][route];\n        for (var i = evList.length - 1; i >= 0; i--) {\n            if (evList[i].callback === callback) {\n                evList.splice(i, 1);\n            }\n        }\n    }\n};\n\n/**\n * Trigger one or many events, firing all bound callbacks. All arguments will\n * be passed throw to the callback function.\n * @param  {String} eventName   Name of the event\n * @param  {*args}  arguments   Will be passed throw to the callback function\n * @return {object}\n */\nshouter.trigger = function(channel, route, ...args) {\n    let results = [];\n\n    if (channel in eventList) {\n        var events = eventList[channel];\n        Object.keys(events)\n            .forEach(routName => {\n                if (route === routName || route === '*' || routName === '*') {\n                    events[routName].forEach(event => results.push(caller(event, args)));\n                }\n            });\n    }\n\n    var promiseResult = Promise.all(results);\n\n    return {\n        save: function() {\n            if (!(channel in oldMessage)) {\n                oldMessage[channel] = [];\n            }\n            oldMessage[channel].push({\n                route: route,\n                args: args\n            });\n\n            return {results: promiseResult};\n        },\n        results: promiseResult\n    };\n};\n\n/**\n * Remove all events\n * Should only be used under test\n * @return {undefined}\n */\nshouter._deleteAllEvents = function() {\n    eventList = {};\n    oldMessage = {};\n};\n\nif (typeof module === 'object' && typeof module.exports === 'object') {\n    exports.__esModule = true;\n    exports.shouter = shouter;\n    exports.default = shouter;\n} else {\n    window.shouter = shouter;\n}\n"],"sourceRoot":"/source/"}
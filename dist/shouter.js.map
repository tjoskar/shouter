{"version":3,"sources":["shouter.js"],"names":["_toConsumableArray","arr","Array","isArray","i","arr2","length","from","Object","defineProperty","exports","value","require","eventList","oldMessage","caller","event","args","Promise","resolve","reject","setTimeout","result","undefined","_context","_ref","context","callback","call","apply","concat","e","on","channel","route","getOldMessage","push","forEach","val","off","arguments","evList","splice","trigger","_len","_key","results","events","keys","routName","promiseResult","all","save","_deleteAllEvents","shouter"],"mappings":"AAAA,YAiBA,SAASA,oBAAmBC,GAAO,GAAIC,MAAMC,QAAQF,GAAM,CAAE,IAAK,GAAIG,GAAI,EAAGC,EAAOH,MAAMD,EAAIK,QAASF,EAAIH,EAAIK,OAAQF,IAAKC,EAAKD,GAAKH,EAAIG,EAAI,OAAOC,GAAe,MAAOH,OAAMK,KAAKN,GAJtLO,OAAOC,eAAeC,QAAS,cAC3BC,OAAO,IAKXC,QANO,mBAMP,IAAIC,cAOAC,cAQAC,OAAS,SAAUC,EAAOC,GAC1B,MAAO,IAAIC,SAAQ,SAACC,EAASC,GACzBC,WAAW,WACP,GAAIC,GAAMC,MACV,KAOI,GAAIC,GAAUC,CANdH,IAASE,EAAAR,EAAMU,QAAND,EAAeT,EAAMW,UAAQC,KAAAC,MAAAJ,GAAAD,GAAAM,OAAA9B,mBAAIiB,KAC1CE,EAAQG,GACV,MAAOS,GACLX,EAAOW,SAgBnBC,GAAK,SAASC,EAASC,EAAOP,EAAUD,EAASS,GAE3CF,IAAWpB,aACbA,UAAUoB,OAGRC,IAASrB,WAAUoB,KACrBpB,UAAUoB,GAASC,OAGvBrB,UAAUoB,GAASC,GAAOE,MACtBT,SAAUA,EACVD,QAASA,IAGTS,GAAiBF,IAAWnB,aAC5BA,WAAWmB,GAASI,QAAQ,SAACC,IACrBJ,IAAUI,EAAIJ,OAAmB,MAAVA,IACdP,EAAQC,KAAAC,MAARF,GAATD,GAAOI,OAAA9B,mBAAcsC,EAAIrB,WAarCsB,IAAM,SAASN,EAASC,EAAOP,GAM/B,GALyB,IAArBa,UAAUlC,SACVqB,EAAWO,EACXA,EAAQ,KAGRD,IAAWpB,YAAaqB,IAASrB,WAAUoB,GAE3C,IAAK,GADDQ,GAAS5B,UAAUoB,GAASC,GACvB9B,EAAIqC,EAAOnC,OAAS,EAAGF,GAAK,EAAGA,IAChCqC,EAAOrC,GAAGuB,WAAaA,GACvBc,EAAOC,OAAOtC,EAAG,IAa7BuC,QAAU,SAASV,EAASC,GAQ5B,IAAK,GAAIU,GAAOJ,UAAUlC,OARYW,EAAIf,MAAA0C,EAAA,EAAAA,EAAA,EAAA,GAAAC,EAAA,EAAAD,EAAAC,EAAAA,IAAJ5B,EAAI4B,EAAA,GAAAL,UAAAK,EAC1C,IAAIC,KAEJ,IAAIb,IAAWpB,WAAW,CACtB,GAAIkC,GAASlC,UAAUoB,EACvBzB,QAAOwC,KAAKD,GACPV,QAAQ,SAAAY,IACDf,IAAUe,GAAsB,MAAVf,GAA8B,MAAbe,IACvCF,EAAOE,GAAUZ,QAAQ,SAAArB,GAWzB,MAXkC8B,GAAQV,KAAKrB,OAAOC,EAAOC,QAK7E,GAAIiC,GAAgBhC,QAAQiC,IAAIL,EAEhC,QACIM,KAAM,WASF,MARMnB,KAAWnB,cACbA,WAAWmB,OAEfnB,WAAWmB,GAASG,MAChBF,MAAOA,EACPjB,KAAMA,KAGF6B,QAASI,IAErBJ,QAASI,IASbG,iBAAmB,WACnBxC,aACAC,eAGAwC,SAAWtB,GAAAA,GAAIO,IAAAA,IAAKI,QAAAA,QAASU,iBAAAA,iBAcjC3C,SAZQ4C,QAAAA,QAaR5C,QAbiBsB,GAAAA,GAcjBtB,QAdqB6B,IAAAA,IAerB7B,QAf0BiC,QAAAA,QAgB1BjC,QAAQ,WAfO4C","file":"shouter.js","sourcesContent":["'use strict';\n\n// Shouter\n// ---------------\n// Bind a callback function to an event.\n//\n//        var help = function() { alert('HELP!'); };\n//        shouter.on('avalanche', '*', help);\n//        shouter.trigger('avalanche', 'danger');\n//        shouter.off('avalanche', help);\n//\n\n// For some reason some people are still using old browsers and systems\nimport 'promise-polyfill';\n\n/**\n * List of registered events\n * @type {Object}\n */\nlet eventList = {};\n\n/**\n * Storage of old messages.\n * Used if a listener wants an already emited message\n * @type {Object}\n */\nlet oldMessage = {};\n\n/**\n * Helper function to make async calls\n * @param {Object}  event\n * @param {Array}   args\n * @return {Promise}\n*/\nlet caller = function (event, args) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            let result;\n            try {\n                result = event.context::event.callback(...args);\n                resolve(result);\n            } catch (e) {\n                reject(e);\n            }\n        });\n    });\n};\n\n\n/**\n * Binds a 'callback' to an event.\n * @param  {String}   channel       Name of the channel\n * @param  {String}   route         Name of the route, optional\n * @param  {function} callback      Callback function\n * @param  {Object}   context       Context of the function 'callback'\n * @param  {Boolian}  getOldMessage Determines if old triggers should be taken under account\n * @return {undefined}\n */\nlet on = function(channel, route, callback, context, getOldMessage) {\n\n    if (!(channel in eventList)) {\n        eventList[channel] = {};\n    }\n\n    if (!(route in eventList[channel])) {\n        eventList[channel][route] = [];\n    }\n\n    eventList[channel][route].push({\n        callback: callback,\n        context: context\n    });\n\n    if (getOldMessage && channel in oldMessage) {\n        oldMessage[channel].forEach((val) => {\n            if (route === val.route || route === '*') {\n                context::callback(...val.args);\n            }\n        });\n    }\n};\n\n/**\n * Remove event(s) from the event-list.\n * @param  {String}   channel    Name of the channel\n * @param  {String}   route      Name of the route, optional\n * @param  {Function} callback   Callback function for selecting a specific event\n * @return {undefined}\n */\nlet off = function(channel, route, callback) {\n    if (arguments.length === 2) {\n        callback = route;\n        route = '*';\n    }\n\n    if (channel in eventList && route in eventList[channel]) {\n        var evList = eventList[channel][route];\n        for (var i = evList.length - 1; i >= 0; i--) {\n            if (evList[i].callback === callback) {\n                evList.splice(i, 1);\n            }\n        }\n    }\n};\n\n/**\n * Trigger one or many events, firing all bound callbacks. All arguments will\n * be passed throw to the callback function.\n * @param  {String} eventName   Name of the event\n * @param  {*args}  arguments   Will be passed throw to the callback function\n * @return {object}\n */\nlet trigger = function(channel, route, ...args) {\n    let results = [];\n\n    if (channel in eventList) {\n        var events = eventList[channel];\n        Object.keys(events)\n            .forEach(routName => {\n                if (route === routName || route === '*' || routName === '*') {\n                    events[routName].forEach(event => results.push(caller(event, args)));\n                }\n            });\n    }\n\n    var promiseResult = Promise.all(results);\n\n    return {\n        save: function() {\n            if (!(channel in oldMessage)) {\n                oldMessage[channel] = [];\n            }\n            oldMessage[channel].push({\n                route: route,\n                args: args\n            });\n\n            return {results: promiseResult};\n        },\n        results: promiseResult\n    };\n};\n\n/**\n * Remove all events\n * Should only be used under test\n * @return {undefined}\n */\nlet _deleteAllEvents = function() {\n    eventList = {};\n    oldMessage = {};\n};\n\nlet shouter = {on, off, trigger, _deleteAllEvents};\n\nexport {shouter, on, off, trigger};\nexport default shouter;\n"],"sourceRoot":"/source/"}
{"version":3,"sources":["lib/promise-polyfill.js"],"names":["_global","require","applyPolyfill","root","bind","fn","thisArg","apply","arguments","Promise","this","TypeError","_state","_value","_deferreds","doResolve","resolve","reject","handle","deferred","me","push","asap","cb","onFulfilled","onRejected","ret","e","newValue","then","finale","call","i","len","length","Handler","done","value","reason","ex","setImmediate","setTimeout","isArray","Array","Object","prototype","toString","all","args","slice","res","val","remaining","constructor","race","values","_setImmediateFn","globalObject"],"mappings":"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","file":"lib/promise-polyfill.js","sourcesContent":["'use strict';\nimport {globalObject} from './global';\n\nlet applyPolyfill = function(root) {\n\n    // Use polyfill for setImmediate for performance gains\n    var asap = (typeof setImmediate === 'function' && setImmediate) ||\n        function(fn) { setTimeout(fn, 1); };\n\n    // Polyfill for Function.prototype.bind\n    function bind(fn, thisArg) {\n        return function() {\n            fn.apply(thisArg, arguments);\n        }\n    }\n\n    var isArray = Array.isArray || function(value) { return Object.prototype.toString.call(value) === '[object Array]' };\n\n    function Promise(fn) {\n        if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');\n        if (typeof fn !== 'function') throw new TypeError('not a function');\n        this._state = null;\n        this._value = null;\n        this._deferreds = []\n\n        doResolve(fn, bind(resolve, this), bind(reject, this))\n    }\n\n    function handle(deferred) {\n        var me = this;\n        if (this._state === null) {\n            this._deferreds.push(deferred);\n            return\n        }\n        asap(function() {\n            var cb = me._state ? deferred.onFulfilled : deferred.onRejected\n            if (cb === null) {\n                (me._state ? deferred.resolve : deferred.reject)(me._value);\n                return;\n            }\n            var ret;\n            try {\n                ret = cb(me._value);\n            }\n            catch (e) {\n                deferred.reject(e);\n                return;\n            }\n            deferred.resolve(ret);\n        })\n    }\n\n    function resolve(newValue) {\n        try { //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n            if (newValue === this) throw new TypeError('A promise cannot be resolved with itself.');\n            if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n                var then = newValue.then;\n                if (typeof then === 'function') {\n                    doResolve(bind(then, newValue), bind(resolve, this), bind(reject, this));\n                    return;\n                }\n            }\n            this._state = true;\n            this._value = newValue;\n            finale.call(this);\n        } catch (e) { reject.call(this, e); }\n    }\n\n    function reject(newValue) {\n        this._state = false;\n        this._value = newValue;\n        finale.call(this);\n    }\n\n    function finale() {\n        for (var i = 0, len = this._deferreds.length; i < len; i++) {\n            handle.call(this, this._deferreds[i]);\n        }\n        this._deferreds = null;\n    }\n\n    function Handler(onFulfilled, onRejected, resolve, reject){\n        this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n        this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n        this.resolve = resolve;\n        this.reject = reject;\n    }\n\n    /**\n     * Take a potentially misbehaving resolver function and make sure\n     * onFulfilled and onRejected are only called once.\n     *\n     * Makes no guarantees about asynchrony.\n     */\n    function doResolve(fn, onFulfilled, onRejected) {\n        var done = false;\n        try {\n            fn(function (value) {\n                if (done) return;\n                done = true;\n                onFulfilled(value);\n            }, function (reason) {\n                if (done) return;\n                done = true;\n                onRejected(reason);\n            })\n        } catch (ex) {\n            if (done) return;\n            done = true;\n            onRejected(ex);\n        }\n    }\n\n    Promise.prototype['catch'] = function (onRejected) {\n        return this.then(null, onRejected);\n    };\n\n    Promise.prototype.then = function(onFulfilled, onRejected) {\n        var me = this;\n        return new Promise(function(resolve, reject) {\n            handle.call(me, new Handler(onFulfilled, onRejected, resolve, reject));\n        })\n    };\n\n    Promise.all = function () {\n        var args = Array.prototype.slice.call(arguments.length === 1 && isArray(arguments[0]) ? arguments[0] : arguments);\n\n        return new Promise(function (resolve, reject) {\n            if (args.length === 0) return resolve([]);\n            var remaining = args.length;\n            function res(i, val) {\n                try {\n                    if (val && (typeof val === 'object' || typeof val === 'function')) {\n                        var then = val.then;\n                        if (typeof then === 'function') {\n                            then.call(val, function (val) { res(i, val) }, reject);\n                            return;\n                        }\n                    }\n                    args[i] = val;\n                    if (--remaining === 0) {\n                        resolve(args);\n                    }\n                } catch (ex) {\n                    reject(ex);\n                }\n            }\n            for (var i = 0; i < args.length; i++) {\n                res(i, args[i]);\n            }\n        });\n    };\n\n    Promise.resolve = function (value) {\n        if (value && typeof value === 'object' && value.constructor === Promise) {\n            return value;\n        }\n\n        return new Promise(function (resolve) {\n            resolve(value);\n        });\n    };\n\n    Promise.reject = function (value) {\n        return new Promise(function (resolve, reject) {\n            reject(value);\n        });\n    };\n\n    Promise.race = function (values) {\n        return new Promise(function (resolve, reject) {\n            for(var i = 0, len = values.length; i < len; i++) {\n                values[i].then(resolve, reject);\n            }\n        });\n    };\n\n    /**\n     * Set the immediate function to execute callbacks\n     * @param fn {function} Function to execute\n     * @private\n     */\n    Promise._setImmediateFn = function _setImmediateFn(fn) {\n        asap = fn;\n    };\n\n    if (!root.Promise) {\n        root.Promise = Promise;\n    }\n\n};\n\nif (!globalObject.Promise) {\n    applyPolyfill(globalObject);\n}\n"],"sourceRoot":"/source/"}